#target Illustratormain ();function main (){	var fontlist = [], filelist = [];	fontFolder = new Folder("/Library/Fonts").selectDlg("Select Fonts folder");	if (fontFolder == null)		return;	filelist = readFontList (fontFolder);	if (filelist.length == 0)	{		alert ("No Opentype or TrueType files found in that folder");		return;	}//	For testing only: use the first 20 fonts	//	filelist = filelist.slice(0,20);//	alert ("seen "+String(filelist.length)+" files");	for (i=0; i<filelist.length; i++)	{		p = getPanoseInfo (filelist[i]);		if (p != null)		{			if (filelist[i].displayName.substring(filelist[i].displayName.length-4) == '.otf' ||				filelist[i].displayName.substring(filelist[i].displayName.length-4) == '.ttf')				fontlist.push ([filelist[i].displayName.substring(0,filelist[i].displayName.length-4), p]);			else				fontlist.push ([filelist[i].displayName, p]);		}	}	if (fontlist.length == 0)	{		alert ("Nothing useful found in that folder");		return;	}//	alert (fontlist.join("\r"));	var currentparams = [ -1,-1,-1,-1,-1, -1,-1,-1,-1,-1 ];	fDlg = new Window('dialog', 'Font List');	fDlg.orientation = 'column';	with (fDlg.add('group'))	{		with (add('group'))		{			orientation = 'column';			alignment = 'right';			with (add('group'))			{				orientation = 'column';				with (add('group'))				{					add('statictext', undefined, "Family Type");					ft = add('dropdownlist', undefined,							[ '(ignore)',							'Any',							'No Fit',							'Latin Text',							'Latin Hand Written',							'Latin Decorative',							'Latin Symbol'					]);				}				with (add('group'))				{					add('statictext', undefined, "Serif Style");					ss = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'Cove',						'Obtuse Cove',						'Square Cove',						'Obtuse Square Cove',						'Square',						'Thin',						'Oval',						'Exaggerated',						'Triangle',						'Normal Sans',						'Obtuse Sans',						'Perpendicular Sans',						'Flared',						'Rounded'					]);				}				with (add('group'))				{					add('statictext', undefined, "Weight");					wt = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'Very Light',						'Light',						'Thin',						'Book',						'Medium',						'Demi',						'Bold',						'Heavy',						'Black',						'Extra Black'					]);				}				with (add('group'))				{					add('statictext', undefined, "Proportion");					pr = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No fit',						'Old Style',						'Modern',						'Even Width',						'Extended',						'Condensed',						'Very Extended',						'Very Condensed',						'Monospaced'					]);				}				with (add('group'))				{					add('statictext', undefined, "Contrast");					co = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'None',						'Very Low',						'Low',						'Medium Low',						'Medium',						'Medium High',						'High',						'Very High'					]);				}				with (add('group'))				{					add('statictext', undefined, "Stroke Variation");					sv = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'No Variation',						'Gradual/Diagonal',						'Gradual/Transitional',						'Gradual/Vertical',						'Gradual/Horizontal',						'Rapid/Vertical',						'Rapid/Horizontal',						'Instant/Vertical',						'Instant/Horizontal'					]);				}				with (add('group'))				{					add('statictext', undefined, "Arm Style");					as = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'Straight Arms/Horizontal',						'Straight Arms/Wedge',						'Straight Arms/Vertical',						'Straight Arms/Single Serif',						'Straight Arms/Double Serif',						'Non-Straight/Horizontal',						'Non-Straight/Wedge',						'Non-Straight/Vertical',						'Non-Straight/Single Serif',						'Non-Straight/Double Serif'					]);				}				with (add('group'))				{					add('statictext', undefined, "Letterform");					lf = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'Normal/Contact',						'Normal/Weighted',						'Normal/Boxed',						'Normal/Flattened',						'Normal/Rounded',						'Normal/Off Center',						'Normal/Square',						'Oblique/Contact',						'Oblique/Weighted',						'Oblique/Boxed',						'Oblique/Flattened',						'Oblique/Rounded',						'Oblique/Off Center',						'Oblique/Square'					]);				}				with (add('group'))				{					add('statictext', undefined, "Midline");					ml = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'Standard/Trimmed',						'Standard/Pointed',						'Standard/Serifed',						'High/Trimmed',						'High/Pointed',						'High/Serifed',						'Constant/Trimmed',						'Constant/Pointed',						'Constant/Serifed',						'Low/Trimmed',						'Low/Pointed',						'Low/Serifed'					]);				}				with (add('group'))				{					add('statictext', undefined, "X Height");					xh = add('dropdownlist', undefined,						[ '(ignore)',						'Any',						'No Fit',						'Constant/Small',						'Constant/Standard',						'Constant/Large',						'Ducking/Small',						'Ducking/Standard',						'Ducking/Large'					]);				}			}		}		showList = add ("listbox");		showList.minimumSize.height = showList.maximumSize.height = 300;		showList.minimumSize.width = showList.maximumSize.width = 200;	}	ft.selection = 0; ft.onChange = function()	{		currentparams[0] = ft.selection.index-1;		updateList (fontlist, showList, currentparams);	}	ss.selection = 0; ss.onChange = function()	{		currentparams[1] = ss.selection.index-1;		updateList (fontlist, showList, currentparams);	}	wt.selection = 0; wt.onChange = function()	{		currentparams[2] = wt.selection.index-1;		updateList (fontlist, showList, currentparams);	}	pr.selection = 0; pr.onChange = function()	{		currentparams[3] = pr.selection.index-1;		updateList (fontlist, showList, currentparams);	}	co.selection = 0; co.onChange = function()	{		currentparams[4] = co.selection.index-1;		updateList (fontlist, showList, currentparams);	}	sv.selection = 0; sv.onChange = function()	{		currentparams[5] = sv.selection.index-1;		updateList (fontlist, showList, currentparams);	}	as.selection = 0; as.onChange = function()	{		currentparams[6] = as.selection.index-1;		updateList (fontlist, showList, currentparams);	}	lf.selection = 0; lf.onChange = function()	{		currentparams[7] = lf.selection.index-1;		updateList (fontlist, showList, currentparams);	}	ml.selection = 0; ml.onChange = function()	{		currentparams[8] = ml.selection.index-1;		updateList (fontlist, showList, currentparams);	}	xh.selection = 0; xh.onChange = function()	{		currentparams[9] = xh.selection.index-1;		updateList (fontlist, showList, currentparams);	}	updateList (fontlist, showList, currentparams);//	for (i=0; i<fontlist.length; i++)//		showList.add ("item", fontlist[i][0]);	fDlg.show();//	alert (currentparams.join("\r"));}function updateList (fontlist, dropdownlist, parm){	var i, j;	while (dropdownlist.items.length > 0)		dropdownlist.remove(dropdownlist.items[0]);	for (i=0; i<fontlist.length; i++)	{		fit = 0;		for (j=0; j<10; j++)		{			if (parm[j] != -1 && fontlist[i][1][j] != parm[j])				break;		}		if (j == 10)			dropdownlist.add ('item', fontlist[i][0]);	}}function readFontList (fromFolder){	var filelist = fromFolder.getFiles("*.otf");	filelist.concat (fromFolder.getFiles("*.ttf"));	return filelist;}function getPanoseInfo (file){	var f, hdr, numTable, t;	var tableEntry;	var length;	f = File(file);	if (!f.open ("r"))		return "cant read";	f.encoding = "BINARY";	// Read TTF/OTF header	hdr = getUlong(f);	if (hdr != 65536	// Microsoft Truetype		&& hdr != 1330926671)	// Adobe OTF ‘OTTO’	{		f.close();	//	alert (“Not a font type I can read…”);		return null;	}	numTable = getUshort (f);/*	Already read:	ul	version	us	numTable	Now skip over	us	searchRange	us	entrySelector	us	rangeShift	to get to start of tables:*/	f.seek (12);/*	Find ‘OS/2’ — OS/2 and Windows Metrics	Each table entry is	ul	tag	ul	checksum	ul	offset	ul	length*/	for (t=0; t<numTable; t++)	{		tableEntry = f.read(16);		if (tableEntry.substr(0,4) == 'OS/2')			break;	}	// Found 'OS/2' table?	if (tableEntry.substr(0,4) != 'OS/2')	{		f.close();		return null;	}	length = (((((tableEntry.charCodeAt(12) << 8 ) +		tableEntry.charCodeAt(13)) << 8 ) +		tableEntry.charCodeAt(14)) << 8 ) +		tableEntry.charCodeAt(15);	// suspicious length?	if (length < 42 || length > 256)	{		fclose (f);		return null;	}	// Locate OS/2 table in file	offset = (((((tableEntry.charCodeAt(8 ) << 8 ) +		tableEntry.charCodeAt(9)) << 8 ) +		tableEntry.charCodeAt(10)) << 8 ) +		tableEntry.charCodeAt(11);	// we can skip the first 32 bytes as these are not interesting (for now)	f.seek (offset+32);	panose = [];	for (t=0; t<10; t++)		panose.push (f.read(1).charCodeAt(0));	f.close();	return panose;}function getUshort (aFile){	var result = aFile.read(2);	return (result.charCodeAt(0)<<8 ) +	result.charCodeAt(1);}function getUlong (aFile){	var result = aFile.read(4);	return ((((result.charCodeAt(0)<<8 ) +	result.charCodeAt(1))<<8 ) +	result.charCodeAt(2)<<8 ) +	result.charCodeAt(3);}